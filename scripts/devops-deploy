#!/usr/bin/env bash
#
# Deploy - Unified deployment tool for Kubernetes, Docker, and cloud platforms
# Usage: devops deploy <target> [options]
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Default settings
ENVIRONMENT="${ENVIRONMENT:-staging}"
NAMESPACE="${NAMESPACE:-default}"
DRY_RUN=false
FORCE=false
TIMEOUT=300
STRATEGY="rolling"
IMAGE_TAG="${IMAGE_TAG:-latest}"

info() { echo -e "${BLUE}ℹ${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
warn() { echo -e "${YELLOW}⚠${NC} $*"; }
error() { echo -e "${RED}✗${NC} $*" >&2; }
header() { echo -e "\n${BOLD}${CYAN}$*${NC}"; }

usage() {
    cat <<EOF
Deploy - Unified deployment tool

Usage: devops deploy <target> [options]

Targets:
  k8s/<deployment>      Deploy to Kubernetes
  docker/<service>      Deploy Docker container
  compose               Deploy with Docker Compose
  helm/<release>        Deploy Helm chart
  ecs/<service>         Deploy to AWS ECS
  lambda/<function>     Deploy AWS Lambda

Options:
  --env=ENVIRONMENT     Target environment (default: staging)
  --namespace=NS        Kubernetes namespace (default: default)
  --tag=TAG             Image tag to deploy (default: latest)
  --strategy=STRATEGY   Deploy strategy: rolling, blue-green, canary (default: rolling)
  --timeout=SECONDS     Deployment timeout (default: 300)
  --dry-run             Show what would be deployed
  --force               Skip confirmation prompts
  --rollback            Rollback to previous version
  -h, --help            Show this help

Examples:
  devops deploy k8s/myapp --env=production --tag=v1.2.3
  devops deploy k8s/myapp --strategy=canary
  devops deploy helm/myapp --namespace=production
  devops deploy compose --env=staging
  devops deploy k8s/myapp --rollback

Environment Variables:
  ENVIRONMENT           Target environment
  NAMESPACE             Kubernetes namespace
  IMAGE_TAG             Docker image tag
  KUBECONFIG            Kubernetes config file

EOF
}

# Pre-flight checks
preflight() {
    header "Pre-flight Checks"

    local checks_passed=true

    # Check kubectl
    if command -v kubectl &>/dev/null; then
        if kubectl cluster-info &>/dev/null 2>&1; then
            success "kubectl: connected to cluster"
        else
            warn "kubectl: installed but not connected"
        fi
    else
        warn "kubectl: not installed"
    fi

    # Check docker
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null 2>&1; then
            success "docker: running"
        else
            warn "docker: installed but daemon not running"
        fi
    else
        warn "docker: not installed"
    fi

    # Check helm
    if command -v helm &>/dev/null; then
        success "helm: $(helm version --short 2>/dev/null || echo 'installed')"
    else
        warn "helm: not installed"
    fi

    # Check aws
    if command -v aws &>/dev/null; then
        if aws sts get-caller-identity &>/dev/null 2>&1; then
            success "aws: authenticated"
        else
            warn "aws: installed but not authenticated"
        fi
    else
        warn "aws: not installed"
    fi

    echo ""
    return 0
}

# Kubernetes deployment
deploy_kubernetes() {
    local deployment="$1"

    if ! command -v kubectl &>/dev/null; then
        error "kubectl not found"
        exit 1
    fi

    header "Deploying to Kubernetes: $deployment"
    info "Namespace: $NAMESPACE"
    info "Environment: $ENVIRONMENT"
    info "Image Tag: $IMAGE_TAG"
    info "Strategy: $STRATEGY"

    # Check deployment exists
    if ! kubectl get deployment "$deployment" -n "$NAMESPACE" &>/dev/null; then
        error "Deployment not found: $deployment in namespace $NAMESPACE"
        kubectl get deployments -n "$NAMESPACE" 2>/dev/null | head -10
        exit 1
    fi

    # Get current state
    local current_image
    current_image=$(kubectl get deployment "$deployment" -n "$NAMESPACE" \
        -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null)
    info "Current image: $current_image"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - would deploy $deployment with tag $IMAGE_TAG"
        return 0
    fi

    # Confirm
    if [[ "$FORCE" != "true" ]]; then
        echo ""
        read -rp "Deploy $deployment to $ENVIRONMENT? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    echo ""

    case "$STRATEGY" in
        rolling)
            info "Using rolling update strategy"
            kubectl set image deployment/"$deployment" \
                "$deployment=$current_image" \
                -n "$NAMESPACE" 2>/dev/null || \
            kubectl rollout restart deployment/"$deployment" -n "$NAMESPACE"
            ;;
        blue-green)
            info "Using blue-green deployment"
            # Create new deployment with -green suffix
            local green_name="${deployment}-green"
            kubectl get deployment "$deployment" -n "$NAMESPACE" -o yaml | \
                sed "s/name: $deployment/name: $green_name/" | \
                kubectl apply -f - 2>/dev/null
            info "Created green deployment: $green_name"
            info "Switch traffic by updating service selector"
            ;;
        canary)
            info "Using canary deployment"
            # Scale down main, create canary with small replica count
            local canary_name="${deployment}-canary"
            kubectl get deployment "$deployment" -n "$NAMESPACE" -o yaml | \
                sed "s/name: $deployment/name: $canary_name/" | \
                sed "s/replicas: [0-9]*/replicas: 1/" | \
                kubectl apply -f - 2>/dev/null
            info "Created canary deployment: $canary_name (1 replica)"
            info "Monitor canary metrics before full rollout"
            ;;
    esac

    # Wait for rollout
    info "Waiting for rollout to complete (timeout: ${TIMEOUT}s)..."
    if kubectl rollout status deployment/"$deployment" -n "$NAMESPACE" --timeout="${TIMEOUT}s"; then
        success "Deployment successful!"
    else
        error "Deployment failed or timed out"
        warn "Run: kubectl rollout undo deployment/$deployment -n $NAMESPACE"
        exit 1
    fi

    # Show status
    echo ""
    header "Deployment Status"
    kubectl get deployment "$deployment" -n "$NAMESPACE" \
        -o custom-columns="NAME:.metadata.name,READY:.status.readyReplicas,AVAILABLE:.status.availableReplicas,AGE:.metadata.creationTimestamp"

    echo ""
}

# Rollback deployment
rollback_kubernetes() {
    local deployment="$1"

    if ! command -v kubectl &>/dev/null; then
        error "kubectl not found"
        exit 1
    fi

    header "Rolling Back: $deployment"
    info "Namespace: $NAMESPACE"

    # Get rollout history
    info "Recent revisions:"
    kubectl rollout history deployment/"$deployment" -n "$NAMESPACE" 2>/dev/null | tail -5

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - would rollback $deployment"
        return 0
    fi

    if [[ "$FORCE" != "true" ]]; then
        echo ""
        read -rp "Rollback $deployment to previous version? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    kubectl rollout undo deployment/"$deployment" -n "$NAMESPACE"

    info "Waiting for rollback..."
    if kubectl rollout status deployment/"$deployment" -n "$NAMESPACE" --timeout="${TIMEOUT}s"; then
        success "Rollback successful!"
    else
        error "Rollback failed"
        exit 1
    fi

    echo ""
}

# Helm deployment
deploy_helm() {
    local release="$1"

    if ! command -v helm &>/dev/null; then
        error "helm not found"
        exit 1
    fi

    header "Deploying Helm Release: $release"
    info "Namespace: $NAMESPACE"
    info "Environment: $ENVIRONMENT"

    # Find chart
    local chart_path=""
    for path in "./charts/$release" "./helm/$release" "./$release" "./"; do
        if [[ -f "$path/Chart.yaml" ]]; then
            chart_path="$path"
            break
        fi
    done

    if [[ -z "$chart_path" ]]; then
        error "Chart not found for release: $release"
        exit 1
    fi

    info "Chart path: $chart_path"

    # Find values file
    local values_file=""
    for vf in "$chart_path/values-$ENVIRONMENT.yaml" "$chart_path/values.$ENVIRONMENT.yaml" "$chart_path/values.yaml"; do
        if [[ -f "$vf" ]]; then
            values_file="$vf"
            break
        fi
    done

    if [[ -n "$values_file" ]]; then
        info "Values file: $values_file"
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - template output:"
        helm template "$release" "$chart_path" \
            --namespace "$NAMESPACE" \
            ${values_file:+-f "$values_file"} \
            --set image.tag="$IMAGE_TAG" 2>/dev/null | head -50
        return 0
    fi

    if [[ "$FORCE" != "true" ]]; then
        echo ""
        read -rp "Deploy Helm release $release? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    helm upgrade --install "$release" "$chart_path" \
        --namespace "$NAMESPACE" \
        --create-namespace \
        ${values_file:+-f "$values_file"} \
        --set image.tag="$IMAGE_TAG" \
        --wait \
        --timeout "${TIMEOUT}s"

    success "Helm release deployed: $release"

    # Show status
    helm status "$release" -n "$NAMESPACE"
    echo ""
}

# Docker Compose deployment
deploy_compose() {
    header "Deploying with Docker Compose"
    info "Environment: $ENVIRONMENT"

    if ! command -v docker &>/dev/null; then
        error "docker not found"
        exit 1
    fi

    # Find compose file
    local compose_file=""
    for cf in "docker-compose.$ENVIRONMENT.yml" "docker-compose.$ENVIRONMENT.yaml" "compose.$ENVIRONMENT.yml" "docker-compose.yml" "compose.yml"; do
        if [[ -f "$cf" ]]; then
            compose_file="$cf"
            break
        fi
    done

    if [[ -z "$compose_file" ]]; then
        error "No docker-compose file found"
        exit 1
    fi

    info "Compose file: $compose_file"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - config:"
        docker compose -f "$compose_file" config 2>/dev/null | head -30
        return 0
    fi

    if [[ "$FORCE" != "true" ]]; then
        read -rp "Deploy with Docker Compose? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    # Pull latest images
    info "Pulling images..."
    docker compose -f "$compose_file" pull

    # Deploy
    info "Starting services..."
    docker compose -f "$compose_file" up -d

    success "Docker Compose deployed"

    # Show status
    docker compose -f "$compose_file" ps
    echo ""
}

# AWS ECS deployment
deploy_ecs() {
    local service="$1"

    if ! command -v aws &>/dev/null; then
        error "aws CLI not found"
        exit 1
    fi

    header "Deploying to AWS ECS: $service"
    info "Environment: $ENVIRONMENT"

    # Find cluster
    local cluster="${ECS_CLUSTER:-$ENVIRONMENT}"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - would update ECS service $service in cluster $cluster"
        aws ecs describe-services --cluster "$cluster" --services "$service" \
            --query 'services[0].{name:serviceName,status:status,desired:desiredCount,running:runningCount}' \
            --output table 2>/dev/null
        return 0
    fi

    if [[ "$FORCE" != "true" ]]; then
        read -rp "Deploy ECS service $service? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    # Force new deployment
    aws ecs update-service \
        --cluster "$cluster" \
        --service "$service" \
        --force-new-deployment >/dev/null

    info "Waiting for deployment..."
    aws ecs wait services-stable --cluster "$cluster" --services "$service"

    success "ECS service deployed: $service"
    echo ""
}

# AWS Lambda deployment
deploy_lambda() {
    local function="$1"

    if ! command -v aws &>/dev/null; then
        error "aws CLI not found"
        exit 1
    fi

    header "Deploying AWS Lambda: $function"

    # Check for zip file or S3 location
    local code_source=""
    if [[ -f "dist/$function.zip" ]]; then
        code_source="dist/$function.zip"
    elif [[ -f "$function.zip" ]]; then
        code_source="$function.zip"
    fi

    if [[ -z "$code_source" ]]; then
        error "No deployment package found. Expected: $function.zip or dist/$function.zip"
        exit 1
    fi

    info "Code source: $code_source"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run - would update Lambda function $function"
        aws lambda get-function --function-name "$function" \
            --query 'Configuration.{name:FunctionName,runtime:Runtime,memory:MemorySize,timeout:Timeout}' \
            --output table 2>/dev/null
        return 0
    fi

    if [[ "$FORCE" != "true" ]]; then
        read -rp "Deploy Lambda function $function? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    aws lambda update-function-code \
        --function-name "$function" \
        --zip-file "fileb://$code_source" >/dev/null

    success "Lambda function deployed: $function"

    # Show new version
    aws lambda get-function --function-name "$function" \
        --query 'Configuration.{Version:Version,LastModified:LastModified}' \
        --output table
    echo ""
}

# Parse arguments
TARGET=""
ROLLBACK=false

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            --env=*)
                ENVIRONMENT="${1#*=}"
                ;;
            --namespace=*)
                NAMESPACE="${1#*=}"
                ;;
            --tag=*)
                IMAGE_TAG="${1#*=}"
                ;;
            --strategy=*)
                STRATEGY="${1#*=}"
                ;;
            --timeout=*)
                TIMEOUT="${1#*=}"
                ;;
            --dry-run)
                DRY_RUN=true
                ;;
            --force)
                FORCE=true
                ;;
            --rollback)
                ROLLBACK=true
                ;;
            k8s/*|docker/*|helm/*|ecs/*|lambda/*)
                TARGET="$1"
                ;;
            compose)
                TARGET="compose"
                ;;
            *)
                if [[ -z "$TARGET" ]]; then
                    # Assume k8s deployment
                    TARGET="k8s/$1"
                else
                    error "Unknown option: $1"
                    usage
                    exit 1
                fi
                ;;
        esac
        shift
    done
}

# Main
main() {
    parse_args "$@"

    echo -e "${BOLD}${CYAN}"
    echo "╔══════════════════════════════════════════════════════════╗"
    echo "║                    DEPLOYMENT                            ║"
    echo "╚══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"

    preflight

    if [[ -z "$TARGET" ]]; then
        usage
        exit 0
    fi

    case "$TARGET" in
        k8s/*)
            local deployment="${TARGET#k8s/}"
            if [[ "$ROLLBACK" == "true" ]]; then
                rollback_kubernetes "$deployment"
            else
                deploy_kubernetes "$deployment"
            fi
            ;;
        helm/*)
            local release="${TARGET#helm/}"
            deploy_helm "$release"
            ;;
        compose)
            deploy_compose
            ;;
        ecs/*)
            local service="${TARGET#ecs/}"
            deploy_ecs "$service"
            ;;
        lambda/*)
            local function="${TARGET#lambda/}"
            deploy_lambda "$function"
            ;;
        docker/*)
            # Single container deployment - use compose or k8s
            warn "For single container, use 'compose' or 'k8s/<deployment>'"
            ;;
        *)
            error "Unknown target: $TARGET"
            usage
            exit 1
            ;;
    esac
}

main "$@"
