#!/usr/bin/env bash
#
# Kubernetes Deploy - Advanced Kubernetes deployment management
# Usage: devops k8s-deploy <action> [options]
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Default settings
NAMESPACE="${NAMESPACE:-default}"
CONTEXT="${KUBECONTEXT:-}"
DRY_RUN=false
FORCE=false
TIMEOUT=300
STRATEGY="rolling"

info() { echo -e "${BLUE}ℹ${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
warn() { echo -e "${YELLOW}⚠${NC} $*"; }
error() { echo -e "${RED}✗${NC} $*" >&2; }
header() { echo -e "\n${BOLD}${CYAN}$*${NC}"; }

usage() {
    cat <<EOF
Kubernetes Deploy - Advanced Kubernetes deployment management

Usage: devops k8s-deploy <action> [options]

Actions:
  apply <file|dir>        Apply manifests
  status <deployment>     Check deployment status
  rollout <deployment>    Manage rollout (status, history, undo)
  scale <deployment> <n>  Scale deployment replicas
  restart <deployment>    Rolling restart
  diff <file|dir>         Show diff before applying
  logs <deployment>       View deployment logs
  exec <pod> <cmd>        Execute command in pod

Options:
  --namespace=NS          Kubernetes namespace (default: default)
  --context=CTX           Kubernetes context
  --timeout=SECONDS       Operation timeout (default: 300)
  --strategy=STRATEGY     Deploy strategy: rolling, recreate, blue-green (default: rolling)
  --image=IMAGE           Override image for deployment
  --tag=TAG               Override image tag
  --replicas=N            Override replica count
  --dry-run               Show what would be applied (kubectl --dry-run=client)
  --server-dry-run        Server-side dry run
  --force                 Skip confirmation prompts
  --wait                  Wait for rollout to complete
  -h, --help              Show this help

Examples:
  devops k8s-deploy apply ./k8s/
  devops k8s-deploy apply deployment.yaml --namespace=production
  devops k8s-deploy status myapp --namespace=prod
  devops k8s-deploy rollout myapp --undo
  devops k8s-deploy scale myapp 5
  devops k8s-deploy restart myapp
  devops k8s-deploy diff ./k8s/ --namespace=staging

Environment Variables:
  NAMESPACE               Default namespace
  KUBECONFIG              Kubernetes config file
  KUBECONTEXT             Default context

EOF
}

# Check prerequisites
check_prereqs() {
    if ! command -v kubectl &>/dev/null; then
        error "kubectl is not installed"
        info "Install: https://kubernetes.io/docs/tasks/tools/"
        return 1
    fi

    # Check cluster connectivity
    if ! kubectl cluster-info &>/dev/null; then
        error "Cannot connect to Kubernetes cluster"
        info "Check KUBECONFIG or run: kubectl config current-context"
        return 1
    fi

    return 0
}

# Get kubectl command with common options
kctl() {
    local args=("kubectl")

    if [[ -n "$NAMESPACE" ]]; then
        args+=("-n" "$NAMESPACE")
    fi

    if [[ -n "$CONTEXT" ]]; then
        args+=("--context" "$CONTEXT")
    fi

    "${args[@]}" "$@"
}

# Apply manifests
cmd_apply() {
    local target="$1"
    local image="${2:-}"
    local tag="${3:-}"

    header "Applying Kubernetes Manifests"

    if [[ ! -e "$target" ]]; then
        error "File or directory not found: $target"
        return 1
    fi

    local apply_args=("-f" "$target")

    if [[ "$DRY_RUN" == "true" ]]; then
        apply_args+=("--dry-run=client")
        info "[DRY RUN] Validating manifests..."
    fi

    # Show what will be applied
    info "Target: $target"
    info "Namespace: $NAMESPACE"

    if [[ -n "$CONTEXT" ]]; then
        info "Context: $CONTEXT"
    fi

    # If image override specified, use kustomize or sed
    if [[ -n "$image" ]] || [[ -n "$tag" ]]; then
        local temp_dir
        temp_dir=$(mktemp -d)
        trap 'rm -rf "$temp_dir"' EXIT

        if [[ -d "$target" ]]; then
            cp -r "$target"/* "$temp_dir/"
        else
            cp "$target" "$temp_dir/"
        fi

        if [[ -n "$image" ]]; then
            find "$temp_dir" -name "*.yaml" -o -name "*.yml" | while read -r f; do
                sed -i "s|image:.*|image: $image|g" "$f"
            done
            info "Image override: $image"
        fi

        if [[ -n "$tag" ]]; then
            find "$temp_dir" -name "*.yaml" -o -name "*.yml" | while read -r f; do
                sed -i "s|image: \(.*\):.*|image: \1:$tag|g" "$f"
            done
            info "Tag override: $tag"
        fi

        target="$temp_dir"
        apply_args=("-f" "$target")
    fi

    # Apply
    kctl apply "${apply_args[@]}"

    if [[ "$DRY_RUN" != "true" ]]; then
        success "Manifests applied successfully"

        # Wait for rollout if requested
        if [[ "${WAIT:-false}" == "true" ]]; then
            info "Waiting for rollout..."
            # Find deployments in the applied manifests
            local deployments
            deployments=$(kctl get -f "$target" -o jsonpath='{.items[?(@.kind=="Deployment")].metadata.name}' 2>/dev/null || echo "")
            for dep in $deployments; do
                kctl rollout status "deployment/$dep" --timeout="${TIMEOUT}s"
            done
        fi
    fi
}

# Check deployment status
cmd_status() {
    local deployment="$1"

    header "Deployment Status: $deployment"

    # Get deployment info
    kctl get deployment "$deployment" -o wide

    echo ""
    info "Pods:"
    kctl get pods -l "app=$deployment" -o wide 2>/dev/null || \
        kctl get pods | grep "$deployment" || \
        warn "No pods found matching $deployment"

    echo ""
    info "Events:"
    kctl get events --field-selector "involvedObject.name=$deployment" --sort-by='.lastTimestamp' | tail -10

    echo ""
    info "Rollout Status:"
    kctl rollout status "deployment/$deployment" --timeout=5s 2>/dev/null || true
}

# Manage rollout
cmd_rollout() {
    local deployment="$1"
    local action="${2:-status}"

    header "Rollout: $deployment"

    case "$action" in
        status)
            kctl rollout status "deployment/$deployment"
            ;;
        history)
            kctl rollout history "deployment/$deployment"
            ;;
        undo|rollback)
            if [[ "$DRY_RUN" == "true" ]]; then
                info "[DRY RUN] Would rollback $deployment"
            else
                if [[ "$FORCE" != "true" ]]; then
                    read -rp "Rollback $deployment to previous version? (y/n): " confirm
                    [[ "$confirm" != "y" ]] && { info "Aborted"; return 0; }
                fi
                kctl rollout undo "deployment/$deployment"
                success "Rollback initiated"
                kctl rollout status "deployment/$deployment"
            fi
            ;;
        pause)
            kctl rollout pause "deployment/$deployment"
            success "Rollout paused"
            ;;
        resume)
            kctl rollout resume "deployment/$deployment"
            success "Rollout resumed"
            ;;
        restart)
            kctl rollout restart "deployment/$deployment"
            success "Rolling restart initiated"
            kctl rollout status "deployment/$deployment"
            ;;
        *)
            error "Unknown rollout action: $action"
            return 1
            ;;
    esac
}

# Scale deployment
cmd_scale() {
    local deployment="$1"
    local replicas="$2"

    header "Scaling: $deployment"

    if [[ -z "$replicas" ]]; then
        error "Replica count required"
        return 1
    fi

    info "Scaling $deployment to $replicas replicas"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY RUN] Would scale to $replicas replicas"
        return 0
    fi

    kctl scale "deployment/$deployment" --replicas="$replicas"
    success "Scaled to $replicas replicas"

    # Show new status
    kctl get deployment "$deployment"
}

# Rolling restart
cmd_restart() {
    local deployment="$1"

    header "Rolling Restart: $deployment"

    if [[ "$DRY_RUN" == "true" ]]; then
        info "[DRY RUN] Would restart $deployment"
        return 0
    fi

    kctl rollout restart "deployment/$deployment"
    success "Rolling restart initiated"

    if [[ "${WAIT:-false}" == "true" ]]; then
        kctl rollout status "deployment/$deployment" --timeout="${TIMEOUT}s"
    fi
}

# Show diff before applying
cmd_diff() {
    local target="$1"

    header "Diff: $target"

    if [[ ! -e "$target" ]]; then
        error "File or directory not found: $target"
        return 1
    fi

    kctl diff -f "$target" || true
}

# View logs
cmd_logs() {
    local deployment="$1"
    local follow="${2:-false}"

    header "Logs: $deployment"

    local log_args=("-l" "app=$deployment")

    if [[ "$follow" == "true" ]]; then
        log_args+=("-f")
    fi

    log_args+=("--tail=100")

    kctl logs "${log_args[@]}" 2>/dev/null || \
        kctl logs "deployment/$deployment" --tail=100
}

# Exec into pod
cmd_exec() {
    local pod="$1"
    shift
    local cmd="${*:-/bin/sh}"

    header "Exec: $pod"

    kctl exec -it "$pod" -- $cmd
}

# Main
main() {
    local action=""
    local target=""
    local image=""
    local tag=""
    local replicas=""
    local rollout_action=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            apply|status|rollout|scale|restart|diff|logs|exec)
                action="$1"
                shift
                [[ $# -gt 0 ]] && [[ ! "$1" =~ ^-- ]] && target="$1" && shift
                [[ $# -gt 0 ]] && [[ ! "$1" =~ ^-- ]] && {
                    case "$action" in
                        scale) replicas="$1" ;;
                        rollout) rollout_action="$1" ;;
                    esac
                    shift
                }
                ;;
            --namespace=*) NAMESPACE="${1#*=}"; shift ;;
            --context=*) CONTEXT="${1#*=}"; shift ;;
            --timeout=*) TIMEOUT="${1#*=}"; shift ;;
            --strategy=*) STRATEGY="${1#*=}"; shift ;;
            --image=*) image="${1#*=}"; shift ;;
            --tag=*) tag="${1#*=}"; shift ;;
            --replicas=*) replicas="${1#*=}"; shift ;;
            --dry-run) DRY_RUN=true; shift ;;
            --force) FORCE=true; shift ;;
            --wait) WAIT=true; shift ;;
            --undo) rollout_action="undo"; shift ;;
            -f|--follow) FOLLOW=true; shift ;;
            -h|--help) usage; exit 0 ;;
            *) shift ;;
        esac
    done

    if [[ -z "$action" ]]; then
        usage
        exit 1
    fi

    # Check prerequisites
    check_prereqs || exit 1

    info "Namespace: $NAMESPACE"
    [[ -n "$CONTEXT" ]] && info "Context: $CONTEXT"

    case "$action" in
        apply)
            cmd_apply "$target" "$image" "$tag"
            ;;
        status)
            cmd_status "$target"
            ;;
        rollout)
            cmd_rollout "$target" "${rollout_action:-status}"
            ;;
        scale)
            cmd_scale "$target" "$replicas"
            ;;
        restart)
            cmd_restart "$target"
            ;;
        diff)
            cmd_diff "$target"
            ;;
        logs)
            cmd_logs "$target" "${FOLLOW:-false}"
            ;;
        exec)
            cmd_exec "$target" "${@}"
            ;;
        *)
            error "Unknown action: $action"
            exit 1
            ;;
    esac
}

main "$@"
