#!/usr/bin/env bash
#
# Secrets Management - Manage secrets across Vault, AWS Secrets Manager, etc.
# Usage: devops secrets-manage <action> [path] [options]
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Default settings
BACKEND=""
NAMESPACE="${NAMESPACE:-default}"
FORCE=false

info() { echo -e "${BLUE}ℹ${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
warn() { echo -e "${YELLOW}⚠${NC} $*"; }
error() { echo -e "${RED}✗${NC} $*" >&2; }
header() { echo -e "\n${BOLD}${CYAN}$*${NC}"; }

# Mask sensitive output
mask_value() {
    local value="$1"
    local len=${#value}
    if [[ $len -le 4 ]]; then
        echo "****"
    else
        echo "${value:0:2}$( printf '*%.0s' $(seq 1 $((len - 4))) )${value: -2}"
    fi
}

usage() {
    cat <<EOF
Secrets Management - Manage secrets across different backends

Usage: devops secrets-manage <action> [path] [options]

Actions:
  list [path]           List secrets at path
  get <path>            Get secret value (masked by default)
  set <path>            Set secret value
  delete <path>         Delete a secret
  rotate <path>         Rotate secret value
  sync                  Sync secrets to Kubernetes

Options:
  --backend=BACKEND     Secret backend: vault, aws, gcp, k8s (auto-detected)
  --namespace=NS        Kubernetes namespace (default: default)
  --value=VALUE         Secret value for set action
  --show                Show unmasked value (use with caution)
  --force               Skip confirmation for destructive operations
  -h, --help            Show this help

Backends:
  vault       HashiCorp Vault (requires VAULT_ADDR, VAULT_TOKEN)
  aws         AWS Secrets Manager (requires AWS credentials)
  gcp         GCP Secret Manager (requires GOOGLE_PROJECT)
  k8s         Kubernetes Secrets (requires kubectl context)

Examples:
  devops secrets-manage list
  devops secrets-manage get myapp/database
  devops secrets-manage set myapp/api-key --value="sk_live_xxx"
  devops secrets-manage rotate myapp/database
  devops secrets-manage sync --namespace=production

Environment Variables:
  VAULT_ADDR            Vault server address
  VAULT_TOKEN           Vault authentication token
  AWS_REGION            AWS region for Secrets Manager
  GOOGLE_PROJECT        GCP project for Secret Manager

EOF
}

# Detect backend
detect_backend() {
    if [[ -n "$BACKEND" ]]; then
        echo "$BACKEND"
        return
    fi

    if [[ -n "${VAULT_ADDR:-}" ]]; then
        echo "vault"
    elif [[ -n "${AWS_REGION:-}" ]] || aws sts get-caller-identity &>/dev/null 2>&1; then
        echo "aws"
    elif [[ -n "${GOOGLE_PROJECT:-}" ]]; then
        echo "gcp"
    elif kubectl cluster-info &>/dev/null 2>&1; then
        echo "k8s"
    else
        echo ""
    fi
}

# Check tools
check_tools() {
    local backend="$1"

    case "$backend" in
        vault)
            if ! command -v vault &>/dev/null; then
                error "vault CLI not found"
                exit 1
            fi
            if ! vault status &>/dev/null; then
                error "Vault not authenticated or unreachable"
                exit 1
            fi
            success "Vault backend ready"
            ;;
        aws)
            if ! command -v aws &>/dev/null; then
                error "aws CLI not found"
                exit 1
            fi
            if ! aws sts get-caller-identity &>/dev/null; then
                error "AWS not authenticated"
                exit 1
            fi
            success "AWS Secrets Manager ready"
            ;;
        gcp)
            if ! command -v gcloud &>/dev/null; then
                error "gcloud CLI not found"
                exit 1
            fi
            success "GCP Secret Manager ready"
            ;;
        k8s)
            if ! command -v kubectl &>/dev/null; then
                error "kubectl not found"
                exit 1
            fi
            if ! kubectl cluster-info &>/dev/null; then
                error "Kubernetes cluster not reachable"
                exit 1
            fi
            success "Kubernetes Secrets ready"
            ;;
        *)
            error "Unknown backend: $backend"
            exit 1
            ;;
    esac
}

# List secrets
cmd_list() {
    local path="${1:-}"
    local backend
    backend=$(detect_backend)

    if [[ -z "$backend" ]]; then
        error "No secrets backend detected. Set VAULT_ADDR, AWS_REGION, or configure kubectl."
        exit 1
    fi

    check_tools "$backend"
    header "Listing Secrets ($backend)"

    case "$backend" in
        vault)
            if [[ -z "$path" ]]; then
                vault secrets list 2>/dev/null || vault kv list secret/ 2>/dev/null
            else
                vault kv list "secret/$path" 2>/dev/null
            fi
            ;;
        aws)
            if [[ -z "$path" ]]; then
                aws secretsmanager list-secrets \
                    --query 'SecretList[*].[Name,Description]' \
                    --output table 2>/dev/null
            else
                aws secretsmanager list-secrets \
                    --filter "Key=name,Values=$path" \
                    --query 'SecretList[*].[Name,Description]' \
                    --output table 2>/dev/null
            fi
            ;;
        gcp)
            gcloud secrets list --format="table(name,createTime)" 2>/dev/null
            ;;
        k8s)
            kubectl get secrets -n "$NAMESPACE" \
                -o custom-columns="NAME:.metadata.name,TYPE:.type,AGE:.metadata.creationTimestamp" 2>/dev/null
            ;;
    esac

    echo ""
}

# Get secret
cmd_get() {
    local path="$1"
    local backend
    backend=$(detect_backend)

    if [[ -z "$path" ]]; then
        error "Path required. Usage: devops secrets-manage get <path>"
        exit 1
    fi

    check_tools "$backend"
    header "Getting Secret: $path"

    local value=""

    case "$backend" in
        vault)
            value=$(vault kv get -field=value "secret/$path" 2>/dev/null || \
                    vault kv get "secret/$path" 2>/dev/null)
            ;;
        aws)
            value=$(aws secretsmanager get-secret-value \
                --secret-id "$path" \
                --query SecretString \
                --output text 2>/dev/null)
            ;;
        gcp)
            value=$(gcloud secrets versions access latest --secret="$path" 2>/dev/null)
            ;;
        k8s)
            value=$(kubectl get secret "$path" -n "$NAMESPACE" \
                -o jsonpath='{.data}' 2>/dev/null | \
                python3 -c "import sys,json,base64; d=json.load(sys.stdin); print('\n'.join(f'{k}: {base64.b64decode(v).decode()}' for k,v in d.items()))" 2>/dev/null || \
                kubectl get secret "$path" -n "$NAMESPACE" -o yaml 2>/dev/null)
            ;;
    esac

    if [[ -z "$value" ]]; then
        error "Secret not found: $path"
        exit 1
    fi

    if [[ "${SHOW:-false}" == "true" ]]; then
        warn "Showing unmasked value:"
        echo "$value"
    else
        info "Value (masked): $(mask_value "$value")"
        info "Use --show to display full value"
    fi

    # Log access (audit)
    info "Access logged: $path at $(date -Iseconds)"
    echo ""
}

# Set secret
cmd_set() {
    local path="$1"
    local value="${SECRET_VALUE:-}"
    local backend
    backend=$(detect_backend)

    if [[ -z "$path" ]]; then
        error "Path required. Usage: devops secrets-manage set <path> --value=<value>"
        exit 1
    fi

    if [[ -z "$value" ]]; then
        error "Value required. Use --value=<value>"
        exit 1
    fi

    check_tools "$backend"
    header "Setting Secret: $path"

    # Confirm
    if [[ "$FORCE" != "true" ]]; then
        read -rp "Set secret at '$path'? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    case "$backend" in
        vault)
            vault kv put "secret/$path" value="$value" >/dev/null 2>&1
            ;;
        aws)
            # Try update first, then create
            if aws secretsmanager describe-secret --secret-id "$path" &>/dev/null; then
                aws secretsmanager put-secret-value \
                    --secret-id "$path" \
                    --secret-string "$value" >/dev/null 2>&1
            else
                aws secretsmanager create-secret \
                    --name "$path" \
                    --secret-string "$value" >/dev/null 2>&1
            fi
            ;;
        gcp)
            echo -n "$value" | gcloud secrets create "$path" --data-file=- 2>/dev/null || \
            echo -n "$value" | gcloud secrets versions add "$path" --data-file=- 2>/dev/null
            ;;
        k8s)
            kubectl create secret generic "$path" \
                --from-literal=value="$value" \
                -n "$NAMESPACE" \
                --dry-run=client -o yaml | kubectl apply -f - >/dev/null 2>&1
            ;;
    esac

    success "Secret set: $path"
    info "Change logged at $(date -Iseconds)"
    echo ""
}

# Delete secret
cmd_delete() {
    local path="$1"
    local backend
    backend=$(detect_backend)

    if [[ -z "$path" ]]; then
        error "Path required. Usage: devops secrets-manage delete <path>"
        exit 1
    fi

    check_tools "$backend"
    header "Deleting Secret: $path"

    warn "This will permanently delete the secret!"

    if [[ "$FORCE" != "true" ]]; then
        read -rp "Delete secret '$path'? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    case "$backend" in
        vault)
            vault kv delete "secret/$path" >/dev/null 2>&1
            ;;
        aws)
            aws secretsmanager delete-secret \
                --secret-id "$path" \
                --force-delete-without-recovery >/dev/null 2>&1
            ;;
        gcp)
            gcloud secrets delete "$path" --quiet 2>/dev/null
            ;;
        k8s)
            kubectl delete secret "$path" -n "$NAMESPACE" >/dev/null 2>&1
            ;;
    esac

    success "Secret deleted: $path"
    echo ""
}

# Rotate secret
cmd_rotate() {
    local path="$1"
    local backend
    backend=$(detect_backend)

    if [[ -z "$path" ]]; then
        error "Path required. Usage: devops secrets-manage rotate <path>"
        exit 1
    fi

    check_tools "$backend"
    header "Rotating Secret: $path"

    # Generate new secret
    local new_value
    new_value=$(openssl rand -base64 32 2>/dev/null || \
                head -c 32 /dev/urandom | base64 | tr -d '\n')

    info "Generated new secret value"

    if [[ "$FORCE" != "true" ]]; then
        read -rp "Rotate secret '$path'? [y/N] " confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            info "Cancelled"
            return 0
        fi
    fi

    # Store new value
    SECRET_VALUE="$new_value"
    cmd_set "$path"

    success "Secret rotated: $path"
    warn "Remember to update any services using this secret!"

    # Suggest restart if k8s
    if [[ "$backend" == "k8s" ]] || command -v kubectl &>/dev/null; then
        info "Tip: Restart deployments with: kubectl rollout restart deployment/<name>"
    fi

    echo ""
}

# Sync secrets to Kubernetes
cmd_sync() {
    header "Syncing Secrets to Kubernetes"

    if ! command -v kubectl &>/dev/null; then
        error "kubectl not found"
        exit 1
    fi

    local backend
    backend=$(detect_backend)

    if [[ "$backend" == "k8s" ]]; then
        warn "Already using Kubernetes secrets - nothing to sync"
        return 0
    fi

    info "Source backend: $backend"
    info "Target namespace: $NAMESPACE"

    # Check for External Secrets Operator
    if kubectl get crd externalsecrets.external-secrets.io &>/dev/null; then
        success "External Secrets Operator detected"
        info "Use ExternalSecret CRDs to sync secrets automatically"

        cat <<EOF

Example ExternalSecret:
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: myapp-secrets
  namespace: $NAMESPACE
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: ${backend}-backend
    kind: ClusterSecretStore
  target:
    name: myapp-secrets
  data:
  - secretKey: api-key
    remoteRef:
      key: myapp/api-key

EOF
    else
        warn "External Secrets Operator not found"
        info "Install with: helm install external-secrets external-secrets/external-secrets"

        # Manual sync option
        if [[ "$FORCE" == "true" ]]; then
            info "Performing manual sync..."

            case "$backend" in
                vault)
                    # List and sync from Vault
                    local secrets
                    secrets=$(vault kv list -format=json secret/ 2>/dev/null | jq -r '.[]' || echo "")
                    for secret in $secrets; do
                        local value
                        value=$(vault kv get -field=value "secret/$secret" 2>/dev/null) || continue
                        kubectl create secret generic "$secret" \
                            --from-literal=value="$value" \
                            -n "$NAMESPACE" \
                            --dry-run=client -o yaml | kubectl apply -f - >/dev/null 2>&1
                        info "Synced: $secret"
                    done
                    ;;
                aws)
                    info "Manual AWS sync requires listing specific secrets"
                    ;;
            esac
        fi
    fi

    echo ""
}

# Parse arguments
ACTION=""
TARGET=""
SECRET_VALUE=""
SHOW=false

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            --backend=*)
                BACKEND="${1#*=}"
                ;;
            --namespace=*)
                NAMESPACE="${1#*=}"
                ;;
            --value=*)
                SECRET_VALUE="${1#*=}"
                ;;
            --show)
                SHOW=true
                ;;
            --force)
                FORCE=true
                ;;
            list|get|set|delete|rotate|sync)
                ACTION="$1"
                ;;
            *)
                if [[ -z "$ACTION" ]]; then
                    error "Unknown action: $1"
                    usage
                    exit 1
                else
                    TARGET="$1"
                fi
                ;;
        esac
        shift
    done
}

# Main
main() {
    parse_args "$@"

    if [[ -z "$ACTION" ]]; then
        usage
        exit 0
    fi

    echo -e "${BOLD}${CYAN}"
    echo "╔══════════════════════════════════════════════════════════╗"
    echo "║              SECRETS MANAGEMENT                          ║"
    echo "╚══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"

    case "$ACTION" in
        list)
            cmd_list "$TARGET"
            ;;
        get)
            cmd_get "$TARGET"
            ;;
        set)
            cmd_set "$TARGET"
            ;;
        delete)
            cmd_delete "$TARGET"
            ;;
        rotate)
            cmd_rotate "$TARGET"
            ;;
        sync)
            cmd_sync
            ;;
        *)
            error "Unknown action: $ACTION"
            usage
            exit 1
            ;;
    esac
}

main "$@"
